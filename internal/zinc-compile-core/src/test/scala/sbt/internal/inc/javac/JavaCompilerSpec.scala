package sbt
package internal
package inc
package javac

import java.io.File
import java.net.URLClassLoader

import sbt._
import xsbt.api.{ SameAPI, DefaultShowAPI }
import xsbti.{ Severity, Problem }
import xsbti.compile.{ JavaTools => XJavaTools }
import sbt.io.IO
import sbt.util.Logger
import sbt.internal.util.{ UnitSpec, ConsoleLogger }
import org.scalatest.matchers._

class JavaCompilerSpec extends UnitSpec {

  "Compiling a java file with local javac" should "compile a java file" in works(local)
  it should "issue errors and warnings" in findsErrors(local)

  "Compiling a file with forked javac" should "compile a java file" in works(forked)
  it should "issue errors and warnings" in findsErrors(forked)
  it should "yield the same errors as local javac" in forkSameAsLocal()

  "Documenting a file with forked javadoc" should "document a java file" in docWorks(forked)
  it should "find errors in a java file" in findsDocErrors(forked)

  "Analyzing classes generated by javac" should "matching APIs for stable static-final fields" in analyzeStaticDifference("String", "\"A\"", "\"A\"")
  it should "different APIs for static-final fields with changed values" in analyzeStaticDifference("String", "\"A\"", "\"B\"")
  it should "different APIs for static-final fields with changed types" in analyzeStaticDifference("String", "\"1\"", "int", "1")
  it should "\"safe\" singleton type names " in analyzeStaticDifference("float", "0.123456789f", "0.123456789f")

  def docWorks(compiler: XJavaTools) = IO.withTemporaryDirectory { out =>
    val (result, problems) = doc(compiler, Seq(knownSampleGoodFile), Seq("-d", out.getAbsolutePath))
    result shouldBe true
    (new File(out, "index.html")).exists shouldBe true
    (new File(out, "good.html")).exists shouldBe true
  }

  def works(compiler: XJavaTools) = IO.withTemporaryDirectory { out =>
    val (result, problems) = compile(compiler, Seq(knownSampleGoodFile), Seq("-deprecation", "-d", out.getAbsolutePath))

    result shouldBe true
    (new File(out, "good.class")).exists shouldBe true

    val cl = new URLClassLoader(Array(out.toURI.toURL))
    val clazzz = cl.loadClass("good")
    val mthd = clazzz.getDeclaredMethod("test")
    mthd.invoke(null) shouldBe "Hello"
  }

  def findsErrors(compiler: XJavaTools) = {
    val (result, problems) = compile(compiler, Seq(knownSampleErrorFile), Seq("-deprecation"))
    result shouldBe false
    problems should have size (5)
    val importWarn = warnOnLine(lineno = 1, lineContent = Some("java.rmi.RMISecurityException"))
    val beAnExpectedError = List(importWarn, errorOnLine(3), errorOnLine(4), warnOnLine(7)) reduce (_ or _)
    problems foreach (_ should beAnExpectedError)
  }

  def findsDocErrors(compiler: XJavaTools) = IO.withTemporaryDirectory { out =>
    val (result, problems) = doc(compiler, Seq(knownSampleErrorFile), Seq("-d", out.getAbsolutePath))
    result shouldBe true
    problems should have size (2)
    val beAnExpectedError = List(errorOnLine(3), errorOnLine(4)) reduce (_ or _)
    problems foreach (_ should beAnExpectedError)
  }

  /**
   * Compiles with the given constant values, and confirms that if the strings mismatch, then the
   * the APIs mismatch.
   */
  def analyzeStaticDifference(typeName: String, left: String, right: String): Unit =
    analyzeStaticDifference(typeName, left, typeName, right)

  def analyzeStaticDifference(leftType: String, left: String, rightType: String, right: String): Unit = {
    def compileWithPrimitive(templateType: String, templateValue: String) =
      IO.withTemporaryDirectory { out =>
        // copy the input file to a temporary location and change the templateValue
        val input = new File(out, hasStaticFinalFile.getName())
        IO.writeLines(
          input,
          IO.readLines(hasStaticFinalFile).map { line =>
            line.replace("TYPE", templateType).replace("VALUE", templateValue)
          }
        )

        // then compile it
        val (result, problems) = compile(local, Seq(input), Seq("-d", out.getAbsolutePath))
        result shouldBe true
        val clazzz = new URLClassLoader(Array(out.toURI.toURL)).loadClass("hasstaticfinal")
        ClassToAPI(Seq(clazzz))
      }

    // compile with two different primitive values, and confirm that they match if their
    // values match
    val leftAPI = compileWithPrimitive(leftType, left)
    val rightAPI = compileWithPrimitive(rightType, right)
    leftAPI.size shouldBe rightAPI.size
    ((leftAPI, rightAPI).zipped forall SameAPI.apply) shouldBe (left == right)
  }

  def lineMatches(p: Problem, lineno: Int, lineContent: Option[String] = None): Boolean = {
    def lineContentCheck =
      lineContent match {
        case Some(content) => p.position.lineContent contains content
        case _             => true
      }
    def lineNumberCheck = p.position.line.isDefined && (p.position.line.get == lineno)
    lineNumberCheck && lineContentCheck
  }

  def isError(p: Problem): Boolean = p.severity == Severity.Error
  def isWarn(p: Problem): Boolean = p.severity == Severity.Warn

  def errorOnLine(lineno: Int, lineContent: Option[String] = None) =
    Matcher { (p: Problem) =>
      MatchResult(
        lineMatches(p, lineno, lineContent) && isError(p),
        s"Expected error on line $lineno with content = '$lineContent', but found $p",
        "Problem matched: " + p
      )
    }
  def warnOnLine(lineno: Int, lineContent: Option[String] = None) =
    Matcher { (p: Problem) =>
      MatchResult(
        lineMatches(p, lineno, lineContent) && isWarn(p),
        s"Expected warning on line $lineno with content = '$lineContent', but found $p",
        "Problem matched: " + p
      )
    }

  def forkSameAsLocal() = {
    val (fresult, fproblems) = compile(forked, Seq(knownSampleErrorFile), Seq("-deprecation"))
    val (lresult, lproblems) = compile(local, Seq(knownSampleErrorFile), Seq("-deprecation"))
    fresult shouldBe lresult

    (fproblems zip lproblems) foreach {
      case (f, l) =>
        // TODO - We should check to see if the levenshtein distance of the messages is close...
        if (f.position.sourcePath.isDefined) (f.position.sourcePath.get shouldBe l.position.sourcePath.get)
        else l.position.sourcePath.isDefined shouldBe false

        if (f.position.line.isDefined) f.position.line.get shouldBe l.position.line.get
        else l.position.line.isDefined shouldBe false

        f.severity shouldBe l.severity
    }
  }

  def compile(c: XJavaTools, sources: Seq[File], args: Seq[String]): (Boolean, Array[Problem]) = {
    val log = ConsoleLogger()
    val reporter = new LoggerReporter(10, log)
    val result = c.javac.run(sources.toArray, args.toArray, reporter, log)
    (result, reporter.problems)
  }

  def doc(c: XJavaTools, sources: Seq[File], args: Seq[String]): (Boolean, Array[Problem]) = {
    val log = Logger.Null
    val reporter = new LoggerReporter(10, log)
    val result = c.javadoc.run(sources.toArray, args.toArray, reporter, log)
    (result, reporter.problems)
  }

  // TODO - Create one with known JAVA HOME.
  def forked = JavaTools(JavaCompiler.fork(), Javadoc.fork())

  def local =
    JavaTools(
      JavaCompiler.local.getOrElse(sys.error("This test cannot be run on a JRE, but only a JDK.")),
      Javadoc.local.getOrElse(Javadoc.fork())
    )

  def cwd =
    (new File(new File(".").getAbsolutePath)).getCanonicalFile

  def knownSampleErrorFile =
    new java.io.File(getClass.getResource("test1.java").toURI)

  def knownSampleGoodFile =
    new java.io.File(getClass.getResource("good.java").toURI)

  def hasStaticFinalFile =
    new java.io.File(getClass.getResource("hasstaticfinal.java").toURI)

}
